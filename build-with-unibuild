#!/usr/bin/env bash

# Note: this script needs at least 2 sudoers whitelisting to be able to run under Jenkins

### Constants
BUILD_DIR='multiarch_build'
FULL_BUILD_DIR=`pwd`"/$BUILD_DIR"
RESULTS_DIR='unibuild-repo'
CONTAINER_UPDATE_SCRIPT=" export DEBIAN_FRONTEND=noninteractive && \
    curl -s http://downloads.perfsonar.net/debian/$REPO.gpg.key | apt-key add - && \
    curl -s -o /etc/apt/sources.list.d/$REPO.list http://downloads.perfsonar.net/debian/$REPO.list && \
    apt-get update"

### Variables
if [ -z "$OS" ]; then
    OS=d10
fi
# Other OS to check for building packages
OSes="u18 u20"
if [ -z "$REPO" ]; then
    REPO=perfsonar-minor-snapshot
fi
export OS OSes REPO

# By default, the setup is to build packages for all the supported architectures
# If you want to build for different ones, you should call the scripts with the ARCHES
# variable set similarily to (here for all valid and supported architectures):
# ARCHES='linux/amd64' ./build-with-unibuild
# ARCHES='linux/amd64 linux/arm64' ./build-with-unibuild
if [ -z "$ARCHES" ]; then
    ARCHES='linux/amd64 linux/arm64 linux/armv7 linux/ppc64le'
fi
myARCH="amd64"

### Some local subs
# Clean up
clean_up() {
    # Shutdown all containers
    docker compose down --remove-orphans
    docker volume prune -f
}

# Build foreign architectures, a local function to avoid duplicate code
build_foreign() {
    local OS="$1"
    local p="$2"
    local P_DIR="${RESULTS_DIR}"
    if [ $# -eq 3 ]; then
        P_DIR="$3/unibuild-work/products"
    fi
    # Extract source package
    # sudoers configuration needed for this to work
    sudo /bin/rm -rf $FULL_BUILD_DIR
    mkdir -p $BUILD_DIR
    echo -e "\n# Extracting ${p} in ${BUILD_DIR} to see if we must build it on other architectures."
    # TODO: we should take the newest files present as olders might be existing from a previous run
    if head -1 ${P_DIR}/${p}*.dsc | grep -q '(native)' ; then
        echo "This is a Debian native package, there is no orig tarball."
        cat ${P_DIR}/${p}*.tar.xz | tar -Jx -C $BUILD_DIR --strip-components 1 -f -
    else
        cat ${P_DIR}/${p}*.orig.* | tar -zx -C $BUILD_DIR --strip-components 1 -f -
        cat ${P_DIR}/${p}*.debian.tar.xz | tar -Jx -C $BUILD_DIR -f -
    fi

    for ARCH in ${ARCHES[@]}; do
        LARCH="${ARCH#*\/}"
        LARCH="${LARCH/\/}"
        if [[ $LARCH != "$myARCH" ]]; then
            if grep '^Architecture: ' $BUILD_DIR/debian/control | grep -qv 'Architecture: all'; then
                # We need to build this package for all architectures
                echo -e "\n===== Building \033[1mbinary package ${p}\033[0m on \033[1m${ARCH}\033[0m in \033[1m${OS}_${LARCH}\033[0m container ====="
                # TODO: can we run all ARCHES builds in parallel?
                docker compose exec -T ${OS}_${LARCH} bash -c "\
                    cd $BUILD_DIR && \
                    mk-build-deps --install --tool 'apt-get --yes --no-install-recommends -o Debug::pkgProblemResolver=yes' --remove && \
                    dpkg-buildpackage -us -uc -i -sa -b && \
                    MYARCH=\$(dpkg --print-architecture) && \
                    cd .. && \
                    ls -la *_\${MYARCH}.* && \
                    apt-get -y install ./*_\${MYARCH}.deb && \
                    echo && echo Collecting files from $p ... && \
                    for f in *_\${MYARCH}.*; do mv \${f} ${RESULTS_DIR}; done && \
                    echo '   ... done.' && echo \
                    "
            else
                # Installing packages might be needed to make sure dependencies are satisfied
                # Alternative would be to push packages to repository after each build instead of at the very end
                # Or use a prepopulated snapshot repo
                # But for now we do nothing (and that seems fine)
                echo -e "\033[1mWe don't need to build ${p} for ${ARCH}.\033[0m We'll just skip it."
            fi
        fi
    done
    # TODO: we should also update the local Unibuild repository
    # and make sure it keeps versions of the different packages for rebuilds and multi-arch
    echo
}

### Main
# Launch all foreign ARCH containers
CONTAINERS=""
for ARCH in ${ARCHES[@]}; do
    LARCH="${ARCH#*\/}"
    if [[ $LARCH != "$myARCH" ]]; then
        CONTAINERS+=${OS}_${LARCH/\/}" "
        for LOS in ${OSes[@]}; do
            CONTAINERS+=${LOS}_${LARCH/\/}" "
        done
    fi
done
docker compose up -d $CONTAINERS || exit 1

# Prepare the foreign containers with pS repository, running in background while we'll make the master build
echo -e "\n\033[1mAdding the perfSONAR repository to all containersâ€¦\033[0m\n"
for CONTAINER in ${CONTAINERS[@]}; do
    docker compose exec -dT ${CONTAINER} bash -c "$CONTAINER_UPDATE_SCRIPT" || exit 1
done

# Add pS repo and make the master build with unibuild
docker compose run -T ${OS}_${myARCH} bash -c "$CONTAINER_UPDATE_SCRIPT && \
    echo -e '\n\033[1mAnd then starting the full pScheduler Unibuild.\033[0m\n' && \
    unibuild build \
    "
if [ $? -ne 0 ]; then
    echo -e "\nSomething went wrong with Unibuild, I'll stop here.\n"
    clean_up
    exit 1
fi
echo -e "\n\n*** Unibuild: done! ***\n"

# Then loop on all packages from the unibuild/build-order file
# to see which one we need to build on foreign architectures (QEMU)
for p in `cat ${RESULTS_DIR}/unibuild/debian-package-order`; do
    build_foreign ${OS} ${p}
done

# Finally, loop on the other OS for which we need to build packages differently
# TODO: This loop should check if there is actually a different changelog for the OS it is trying to build, otherwise any already built package will get overwritten
for p in `find . -name Makefile -exec grep -q "(OS_PACKAGING),deb" {} \; -ls | sed 's/.*\.\/\(.*\)\/Makefile/\1/'`; do
    for otherOS in ${OSes[@]}; do
        # Build each package on main architecture first
        echo -e "\n===== Building \033[1mpackage ${p}\033[0m in \033[1m${otherOS}_${myARCH}\033[0m container ====="
        sudo rm -f ${RESULTS_DIR}/unibuild/debian-package-order
        # This is not ideal to run the CONTAINER_UPDATE_SCRIPT each time we build a package,
        # TODO: but that's the only way to collect the return code (run vs exec).  :-/
        docker compose run -T ${otherOS}_${myARCH} bash -c "$CONTAINER_UPDATE_SCRIPT && \
            unibuild build --start ${p} --stop ${p} \
            "
        if [ $? -ne 0 ]; then
            echo -e "\nSomething went wrong with Unibuild on ${otherOS}_${myARCH} for package ${p}, I'll stop here.\n"
            clean_up
            exit 1
        fi
        # The resulting package name is not the package dirname
        result=`head -1 ${RESULTS_DIR}/unibuild/debian-package-order`
        build_foreign ${otherOS} ${result} ${p}
    done
done

clean_up

