#!/usr/bin/env bash

# Note: this script needs at least 2 sudoers whitelisting to be able to run under Jenkins

### Constants
BUILD_DIR='multiarch_build'
FULL_BUILD_DIR=`pwd`"/$BUILD_DIR"
RESULTS_DIR='unibuild-repo'
CONTAINER_UPDATE_SCRIPT=" export DEBIAN_FRONTEND=noninteractive && \
    curl -s http://downloads.perfsonar.net/debian/$REPO.gpg.key | apt-key add - && \
    curl -s -o /etc/apt/sources.list.d/$REPO.list http://downloads.perfsonar.net/debian/$REPO.list && \
    apt-get update && \
    echo && echo"

### Variables
if [ -z "$OS" ]; then
    # Main OS we build on
    OS=u18
fi
# Other OS to check for building packages
OSes="d10 u20"
if [ -z "$REPO" ]; then
    REPO=perfsonar-minor-snapshot
fi
export OS OSes REPO

# By default, the setup is to build packages for all the supported architectures
# If you want to build for different ones, you should call the scripts with the ARCHES
# variable set similarily to (here for all valid and supported architectures):
# ARCHES='linux/amd64' ./build-with-unibuild
# ARCHES='linux/amd64 linux/arm64' ./build-with-unibuild
if [ -z "$ARCHES" ]; then
    ARCHES='linux/amd64 linux/arm64 linux/armv7 linux/ppc64le'
fi
if [ `uname -m` == "x86_64" ]; then
    myARCH="amd64"
else
    echo "Building on a host other than x86_64 is currently not supported"
    exit 1
    # TODO: We should support running on arm64 architecture (Apple Silicon Macs for example)
fi

### Some local subs
# Clean up
clean_up() {
    # Shutdown all containers
    docker compose down --remove-orphans
    docker volume prune -f
}

# Fail
fail() {
    msg=$1
    echo -e "\n\033[1;31mUnrecoverable error!\033[0m"
    echo -e "$1\n"
    clean_up
    exit 1
}

# Build foreign architectures, a local function to avoid duplicate code
build_foreign() {
    local OS="$1"
    local p="$2"
    local P_DIR="${RESULTS_DIR}"
    if [ $# -eq 3 ]; then
        P_DIR="$3/unibuild-work/products"
    fi
    # Extract source package
    # sudoers configuration needed for this to work
    (sudo /bin/rm -rf ${FULL_BUILD_DIR} && mkdir -p ${FULL_BUILD_DIR}) || fail "Cannot setup an empty ${FULL_BUILD_DIR} dir, check your sudo rules."
    echo -e "\n# Extracting ${p} in ${BUILD_DIR} to see if we must build it on other architectures."
    # We take the newest entry, latest built package
    dsc=`ls -1t ${P_DIR}/${p}*.dsc | head -1`
    if head -1 $dsc | grep -q '(native)' ; then
        echo "This is a Debian native package, there is no orig tarball."
        cat ${dsc%.dsc}.debian.tar.xz | tar -Jx -C $BUILD_DIR --strip-components 1 -f -
    else
        cat ${dsc%-*}.orig.* | tar -zx -C $BUILD_DIR --strip-components 1 -f -
        cat ${dsc%.dsc}.debian.tar.xz | tar -Jx -C $BUILD_DIR -f -
    fi

    for ARCH in ${ARCHES[@]}; do
        LARCH="${ARCH#*\/}"
        LARCH="${LARCH/\/}"
        if [[ $LARCH != "$myARCH" ]]; then
            if grep '^Architecture: ' $BUILD_DIR/debian/control | grep -qv 'Architecture: all'; then
                # We need to build this package for all architectures
                echo -e "\n===== Building \033[1mbinary package ${p}\033[0m on \033[1m${ARCH}\033[0m in \033[1m${OS}_${LARCH}\033[0m container ====="
                # TODO: can we run all ARCHES builds in parallel?
                docker compose exec -T ${OS}_${LARCH} bash -c "\
                    cd $BUILD_DIR && \
                    mk-build-deps --install --tool 'apt-get --yes --no-install-recommends -o Debug::pkgProblemResolver=yes' --remove && \
                    dpkg-buildpackage -us -uc -i -sa -b && \
                    MYARCH=\$(dpkg --print-architecture) && \
                    cd .. && \
                    ls -la *_\${MYARCH}.* && \
                    apt-get -y install ./*_\${MYARCH}.deb && \
                    echo && echo Collecting files from $p ... && \
                    for f in *_\${MYARCH}.*; do mv \${f} ${RESULTS_DIR}; done && \
                    echo '   ... done.' && echo \
                    "
            else
                # Installing packages might be needed to make sure dependencies are satisfied
                # Alternative would be to push packages to repository after each build instead of at the very end
                # Or use a prepopulated snapshot repo
                # But for now we do nothing (and that seems fine)
                echo -e "\033[1mWe don't need to build ${p} for ${ARCH}.\033[0m Let's skip it."
            fi
        fi
    done
    # TODO: we should also update the local Unibuild repository
    # and make sure it keeps versions of the different packages for rebuilds and multi-arch
    echo
}

### Main
# Launch all foreign ARCH containers
CONTAINERS=""
for ARCH in ${ARCHES[@]}; do
    LARCH="${ARCH#*\/}"
    if [[ $LARCH != "$myARCH" ]]; then
        CONTAINERS+=${OS}_${LARCH/\/}" "
        for LOS in ${OSes[@]}; do
            CONTAINERS+=${LOS}_${LARCH/\/}" "
        done
    fi
done
docker compose up -d $CONTAINERS || fail "Cannot start containers, please look at your Docker daemon."

echo -e "\n\033[1mAdding the perfSONAR repository to all containers…\033[0m\n"
for CONTAINER in ${CONTAINERS[@]}; do
    # Running in the background, while we'll make the master builds
    docker compose exec -dT ${CONTAINER} bash -c "$CONTAINER_UPDATE_SCRIPT" || fail "Cannot exec the update script in ${CONTAINER}."
done

echo -e "\n\033[1mFirst loop on all additonal OSes (${OSes[@]}) that need specially crafted packages.\033[0m\n"
# TODO: this should probably be better done by Unibuild itself
sudo rm -f ${RESULTS_DIR}/unibuild/* || fail "Cannot empty ${RESULTS_DIR}/unibuild/ dir, check your sudo rules."
# We get the list from all Makefile using the OS_PACKAGING macro
# plus a diff between the unibuild-order on the main OS and the OSes (adding a trailing @ suffix with OS on which to build)
# TODO: But how to make sure they are built in the correct order?
for po in $(docker compose run --rm ${OS}_amd64 bash -c "unibuild order > uorder-mine; \
                for otherOS in ${OSes}; do \
                    [ \"\${otherOS:0:1}\" == \"d\" ] && myDISTRO=Debian; \
                    [ \"\${otherOS:0:1}\" == \"u\" ] && myDISTRO=Ubuntu; \
                    unibuild --define DISTRO=\$myDISTRO --define MAJOR=\${otherOS:1:2} order > uorder-other; \
                    diff uorder-mine uorder-other | awk -v os="\$otherOS" '/^> / {printf \"%s@%s\n\",\$2,os;}'; \
                done; \
                rm -f uorder-mine uorder-other" && \
            find . -name Makefile -exec grep -q "(OS_PACKAGING),deb" {} \; -ls | sed 's/.*\.\/\(.*\)\/Makefile/\1/' \
            ); do
    for otherOS in ${OSes[@]}; do
        # Package name and OS on which to build
        p=${po%@*}
        o=${po#*@}
        if [[ "$o" != "$p" && "$o" != "$otherOS" ]]; then
            # If we don't have OS information or the OS is different than the one we're going to build for, we skip
            break
        fi
        # Build each package on main architecture first
        echo -e "\n===== Building \033[1mpackage ${p}\033[0m in \033[1m${otherOS}_${myARCH}\033[0m container ====="
        # This is not ideal to run the CONTAINER_UPDATE_SCRIPT each time we build a package,
        # TODO: but that's the only way to collect the return code (run vs exec).  :-/
        docker compose run --rm -T ${otherOS}_${myARCH} bash -c "$CONTAINER_UPDATE_SCRIPT && \
            unibuild build --start ${p} --stop ${p} \
            "
        if [ $? -ne 0 ]; then
            fail "Something went wrong with Unibuild on ${otherOS}_${myARCH} for package ${p}, I'll stop here."
        fi
        # The resulting package name is not the package dirname
        result=`head -1 ${RESULTS_DIR}/unibuild/debian-package-order`
        # We now need to build it on foreign architectures
        build_foreign ${otherOS} ${result} ${p} || fail "Something went wrong building foreign arch package for ${result} from ${p}"
        # Remove leftovers to not confuse the next build
        sudo rm -f ${RESULTS_DIR}/unibuild/* || fail "Cannot empty ${RESULTS_DIR}/unibuild/ dir, check your sudo rules."
    done
done

# Add pS repo (see TODO in otherOS loop above) and make the master build on the main OS with unibuild
echo -e "\n===== \033[1mStarting the main full pScheduler Unibuild in ${OS}_${myARCH} container\033[0m =====\n"
docker compose run --rm -T ${OS}_${myARCH} bash -c "$CONTAINER_UPDATE_SCRIPT && \
    unibuild build \
    "
if [ $? -ne 0 ]; then
    fail "Something went wrong with Unibuild, I'll stop here."
fi
echo -e "\n\n*** Unibuild: done! ***\n"

# Then loop on all packages from the unibuild/build-order file
# to see which one we need to build on foreign architectures
for p in `cat ${RESULTS_DIR}/unibuild/debian-package-order`; do
    build_foreign ${OS} ${p} || fail "Something went wrong building foreign arch package for ${p}"
done

echo -e "\n*** All done! ***\n"
clean_up

