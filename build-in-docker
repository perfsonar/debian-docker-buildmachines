#!/usr/bin/env bash

# Usage info
show_help() {
    cat << EOF
    Usage: ${0##*/} -dBD [args_as_for_ps-source-builder] [gitrepo]
    This script will build docker images and launch a git repo build in a container
    Requirements:
        - Needs to be in a directory at the same level as the gitrepo to be built
        - The source branch to build from need to be checked out
        - Functionnal docker buildx setup

    Arguments understood:
        -d don't rebuild Docker images but use locally existing one
        -B don't rebuild source package but use previously build one
        -D debug build, will get you into a shell instead of doing the build

        - all other args are directly passed to the ps-source-builder script
          but they need to be separated with a blank space ' '
        - gitrepo: name of an already checked out git repository to build

    The OSimage and the pS repo used to build the package are coming from what
    is defined in the debian/gbp.conf file, respectively in the builder and
    debian-branch values.
    
    Some examples:
    ./build-in-docker -t debian/stretch/4.4.0-1.b1-1 toolkit
    package=pscheduler-archiver-rabbitmq ./build-in-docker -b 4.4.0 pscheduler
EOF
}

# Defaults
#declare -a ARCHES=("linux/amd64")
declare -a ARCHES=("linux/amd64" "linux/arm64")
#declare -a ARCHES=("linux/amd64" "linux/ppc64le")
# Valid values for ARCH:
# linux/amd64
# linux/arm64
# linux/arm/v7
# linux/arm/v5
# linux/i386
# linux/ppc64le
build_docker_images=true
source_and_binary=true
need_shift=false
OTHEROPT=1

# Parsing options
while getopts "dBDhb:t:ksu" OPT; do
    case $OPT in
        d) build_docker_images=false ; need_shift=true ;;
        B) source_and_binary=false ; need_shift=true ;;
        D) debug_build="bash" ; need_shift=true ;;
# The other options will get passed to ps-source-builder so we must not shift them
        b|t) ((OTHEROPT+=2)) ;;
        k|s|u) ((OTHEROPT+=1)) ;;
        h)
            show_help >&2
            exit 1 ;;
    esac
done
shift $((OPTIND-OTHEROPT))

# Get the gitrepo to build
GITREPO=`echo $@ | awk '{print $NF}'`
if [[ "$GITREPO" =~ ^(pscheduler|minor-packages)$ && -z "$package" ]]; then
    echo "For pscheduler and minor-packages repo, the package variable needs to be set to the package to build!"
    exit 1
elif [ -z "$package" ]; then
    package="."
fi

# Check if directory contains a Debian package to build
GBPCONF=`find ../$GITREPO/$package -path */debian/gbp.conf`
if [ $? -ne 0 ]; then
    echo "This doesn't seem to be a package I can build."
    echo "There is no debian/gbp.conf file in ../$GITREPO/$package"
    exit 1
fi

# Which pS repo are we building for?
# TODO: when a tag is given, we should build from staging
REPO=`awk '/debian-branch / {gsub("\.[0-9]+$","",$3); print "perfsonar-"$3"-snapshot"}' $GBPCONF`

# Which OS are we building on?
OSimage=`awk '/ DIST=/ {gsub("DIST=","",$3); print $3}' $GBPCONF`
case $OSimage in
    bionic) OSimage=ubuntu:$OSimage ;;
    buster) OSimage=debian:$OSimage ;;
    focal) OSimage=ubuntu:$OSimage ;;
    stretch) OSimage=debian:$OSimage ;;
esac
export OSimage ARCH REPO useproxy
if [ -n "$proxy" ]; then
    # If $proxy is set, then we will use it
    useproxy=with
else
    useproxy=without
fi

# Initialise
LOGS_PREFIX="logs/binary_build"
mkdir -p ${LOGS_PREFIX%%/*}
rm -f ${LOGS_PREFIX}_*.log
# We will launch only the upper declared containers ARCH
CONTAINERS=""
for ARCH in ${ARCHES[@]}; do
    LARCH=${ARCH#*\/}
    CONTAINERS+=${LARCH/\/}"_build "
done
# ARCH need to be set before calling docker compose
ARCH=linux/amd64
docker compose down

if $build_docker_images ; then
    # Loop on all ARCHES we want to build for to prepare images
    for ARCH in ${ARCHES[@]}; do
        echo -e "\n\033[1;35m============\033[0;35m\nBuilding OS: $OSimage.$ARCH - pS repo: $REPO\n\033[1m============\033[0m\n"
        # Build the images, sequentially so that caching is effective
        docker buildx bake --load deb_build
    done
else
    echo -e "\n\033[1;33m -d\033[0;33m : I'm not building Docker images but will use the ones already existing in the local registry.\033[0m\n"
fi

# Launch all containers, with deb_build running on amd64
# TODO: deb_build should be running on the main Docker host ARCH, which might not always be amd64
ARCH=linux/amd64 docker compose up -d deb_build $CONTAINERS

if ${source_and_binary} ; then
    # Build source package and feed all the parameters to ps-builder
    echo -e "\n\033[1m===== Building source package in source-build container =====\033[0m"
    ARCH=linux/amd64 docker compose exec --user psbuild -e package=$package deb_build /usr/local/bin/ps-source-builder $*
    # TODO: how to actually stop?
    [ $? -eq 0 ] || exit 1
else
    echo -e "\n\033[1;33m -B : I'm not building the source package, but will use the one already existing in the local ../build_source directory.\033[0m\n"
fi

# Build binary package for all architectures
for ARCH in ${ARCHES[@]}; do
    LARCH=${ARCH#*\/}
    LARCH=${LARCH/\/}
    echo -e "\n===== Building \033[1mbinary package\033[0m on \033[1m$ARCH.$OSimage\033[0m in \033[1m$LARCH-build\033[0m container ====="
    [ -n "$debug_build" ] && echo -e "\033[1;33m -D : We will run a debug binary build, i.e. call $debug_build.\033[0m\n"
    # TODO: can we run all builds in parallel?
    docker compose exec --user psbuild -e package=$package ${LARCH}_build /usr/local/bin/ps-binary-builder $GITREPO $debug_build
done

# Shuting down
echo -e "\nNow stopping all containers."
ARCH=linux/amd64 docker compose down

### Debugging
# ARCH=linux/amd64 OSimage=debian:stretch REPO=perfsonar-4.4-snapshot docker compose up -d deb_build amd64_build
### Running again a binary build with same source package
# ARCH=amd64 OSimage=debian:stretch REPO=perfsonar-4.4-snapshot docker compose exec --user psbuild amd64_build /usr/local/bin/ps-binary-builder $GITREPO

